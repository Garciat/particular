<body style="margin:0"></body>
<script src="http://gbrlgrct.com/gists/07d74ba686ce04eccb11faa44f2ae229/functional.js"></script>
<script>
'use script';

// === SETUP

const SPACEW = document.body.clientWidth;
const SPACEH = document.body.clientHeight;

const canvas = document.createElement('canvas');
canvas.width = SPACEW;
canvas.height = SPACEH;
document.body.appendChild(canvas);

const ctx = canvas.getContext('2d');

// === MATHS

Math.TAU = 2 * Math.PI;

class Vec2 {
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    copy() {
        return new Vec2(this.x, this.y);
    }

    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }

    length() {
        return Math.sqrt(this.lengthSq());
    }

    norm() {
        return this.copy().sdiv_(this.length());
    }

    add(v) {
        return this.copy().add_(v);
    }

    add_(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }

    sub(v) {
        return this.copy().sub_(v);
    }

    sub_(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }

    smul(k) {
        return this.copy().smul_(k);
    }

    smul_(k) {
        this.x *= k;
        this.y *= k;
        return this;
    }

    sdiv(k) {
        return this.copy().sdiv_(k);
    }

    sdiv_(k) {
        this.x /= k;
        this.y /= k;
        return this;
    }

    static zero() {
        return Vec2.fromXY(0, 0);
    }

    static fromXY(x, y) {
        return new Vec2(x, y);
    }

    static fromRads(r) {
        return Vec2.fromXY(Math.cos(r), Math.sin(r));
    }

    static fromAngle(a) {
        return Vec2.fromRads(a / 360 * Math.TAU);
    }
}

// === GENERATION

function uniformI(a, b) {
    return Math.floor(a + (b - a) * Math.random());
}

function makeChispa(pos, spd, hue) {
    return {
        color: 'hsla(' + hue + ', 100%, ' + uniformI(20, 80) + '%, 1)',
        size: uniformI(2, 6),
        pos: pos,
        spd: spd,
        ts: Date.now()
    };
}

function* makeSpark(pos, spd0, n) {
    const hue = uniformI(0, 360);
    for (let i = 0; i < n; ++i) {
        const spd = Vec2.fromRads(Math.random() * Math.TAU).smul(25 * Math.random());
        yield makeChispa(pos.copy(), spd0.add(spd), hue);
    }
}

// === STATE

let chispitas = [];

let tracers = [];

let sinks = [];

let mousePositions = [];

let mousePosition = Vec2.zero();

let mouseSpeed = Vec2.zero();

let shouldProduce = false;

// === EVENTS

canvas.addEventListener('mousemove', function (ev) {
    const pos = Vec2.fromXY(ev.clientX, ev.clientY);

    mousePosition = pos;
});

canvas.addEventListener('mousedown', function (ev) {
    const pos = Vec2.fromXY(ev.clientX, ev.clientY);

    if (ev.button === 0) {
        shouldProduce = true;
    } else if (ev.button === 1) {
        let tracer = makeChispa(pos, Vec2.zero(), 0);
        tracer.path = [];
        tracers.push(tracer)
    } else if (ev.button === 2) {
        sinks.push({ pos: pos, force: Math.random() })
    }
});

window.addEventListener('mouseup', function (ev) {
    if (ev.button === 0) {
        shouldProduce = false;
    }
});

canvas.addEventListener('contextmenu', function (ev) {
    ev.preventDefault();
});

// produce sparks
setInterval(function () {
    if (!shouldProduce) return;

    const nuevas = makeSpark(mousePosition, mouseSpeed, uniformI(10, 20));

    chispitas = chispitas.concat(Array.from(nuevas));
}, 16)

// mouse "smoothing"
setInterval(function () {
    mousePositions.push(mousePosition);

    if (mousePositions.length === 10) {
        mousePositions.shift();
    }

    const spd =
        chain(mousePositions)
        .pairwise()
        .map(ps => ps[1].sub(ps[0]))
        .reduce(Vec2.zero(), (s, p) => s.add(p))
        .sdiv(mousePositions.length);

    mouseSpeed = spd;
}, 16);

// clean up
setInterval(function () {
    chispitas = chispitas.filter(p => (Date.now() - p.ts) < 10000);
    tracers = tracers.filter(p => (Date.now() - p.ts) < 10000);
}, 200)

// === DRAWING

function draw() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, SPACEW, SPACEH);

    for (let chispa of chispitas) {
        ctx.fillStyle = chispa.color;
        ctx.beginPath();
        ctx.arc(chispa.pos.x, chispa.pos.y, chispa.size, 0, Math.TAU);
        ctx.fill();

        chispa.pos.add_(chispa.spd);

        for (let sink of sinks) {
            chispa.spd.add_(sink.pos.sub(chispa.pos).norm().smul(sink.force));
        }
    }

    for (let tracer of tracers) {
        ctx.fillStyle = tracer.color;
        ctx.beginPath();
        ctx.arc(tracer.pos.x, tracer.pos.y, tracer.size, 0, Math.TAU);
        ctx.fill();

        tracer.pos.add_(tracer.spd);

        for (let sink of sinks) {
            tracer.spd.add_(sink.pos.sub(tracer.pos).norm().smul(sink.force));
        }

        tracer.path.push(tracer.pos.copy());

        ctx.beginPath();
        ctx.moveTo(tracer.path[0].x, tracer.path[0].y);
        for (let p of tracer.path) {
            ctx.lineTo(p.x, p.y);
        }
        ctx.strokeStyle = tracer.color;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    for (let sink of sinks) {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(sink.pos.x, sink.pos.y, 10 * sink.force, 0, Math.TAU);
        ctx.fill();
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

// === GO !

loop();

</script>