<body style="margin:0"></body>
<script src="http://gbrlgrct.com/gists/07d74ba686ce04eccb11faa44f2ae229/functional.js"></script>
<script>
'use script';

// === SETUP

const SPACEW = document.body.clientWidth;
const SPACEH = document.body.clientHeight;

const canvas = document.createElement('canvas');
canvas.width = SPACEW;
canvas.height = SPACEH;
document.body.appendChild(canvas);

const ctx = canvas.getContext('2d');

// === MATHS

Math.TAU = 2 * Math.PI;

class Vec2 {
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    copy() {
        return new Vec2(this.x, this.y);
    }

    add(v) {
        return this.copy().add_(v);
    }

    add_(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }

    sub(v) {
        return this.copy().sub_(v);
    }

    sub_(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }

    smul(k) {
        return this.copy().smul_(k);
    }

    smul_(k) {
        this.x *= k;
        this.y *= k;
        return this;
    }

    sdiv(k) {
        return this.copy().sdiv_(k);
    }

    sdiv_(k) {
        this.x /= k;
        this.y /= k;
        return this;
    }

    static zero() {
        return Vec2.fromXY(0, 0);
    }

    static fromXY(x, y) {
        return new Vec2(x, y);
    }

    static fromRads(r) {
        return Vec2.fromXY(Math.cos(r), Math.sin(r));
    }

    static fromAngle(a) {
        return Vec2.fromRads(a / 360 * Math.TAU);
    }
}

// === GENERATION

function uniformI(a, b) {
    return Math.floor(a + (b - a) * Math.random());
}

function makeChispa(pos, spd, hue) {
    return {
        color: 'hsla(' + hue + ', 100%, ' + uniformI(20, 80) + '%, 1)',
        size: uniformI(2, 6),
        pos: pos,
        spd: spd
    };
}

function* makeSpark(pos, spd0, n) {
    const hue = uniformI(0, 360);
    for (let i = 0; i < n; ++i) {
        const spd = Vec2.fromRads(Math.random() * Math.TAU).smul(25 * Math.random());
        yield makeChispa(pos.copy(), spd0.add(spd), hue);
    }
}

// === STATE

let chispitas = [];

let mousePositions = [];

let mousePosition = Vec2.zero();

let mouseSpeed = Vec2.zero();

// === EVENTS

canvas.addEventListener('click', function (ev) {
    const pos = Vec2.fromXY(ev.clientX, ev.clientY);

    const nuevas = makeSpark(pos, mouseSpeed, uniformI(40, 80));

    chispitas = chispitas.concat(Array.from(nuevas));
});

canvas.addEventListener('mousemove', function (ev) {
    const pos = Vec2.fromXY(ev.clientX, ev.clientY);

    mousePosition = pos;
});

// mouse "smoothing"
setInterval(function () {
    mousePositions.push(mousePosition);

    if (mousePositions.length === 10) {
        mousePositions.shift();
    }

    const spd =
        chain(mousePositions)
        .pairwise()
        .map(ps => ps[1].sub(ps[0]))
        .reduce(Vec2.zero(), (s, p) => s.add(p))
        .sdiv(mousePositions.length);

    mouseSpeed = spd;
}, 16);

// clean up
setInterval(function () {
    chispitas = chispitas.filter(p => p.pos.y < SPACEH + 100);
}, 200)

// === DRAWING

function draw() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, SPACEW, SPACEH);

    for (let chispa of chispitas) {
        ctx.fillStyle = chispa.color;
        ctx.beginPath();
        ctx.arc(chispa.pos.x, chispa.pos.y, chispa.size, 0, Math.TAU);
        ctx.fill();

        chispa.pos.add_(chispa.spd);
        chispa.spd.add_(Vec2.fromXY(0, 1));
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

// === GO !

loop();

</script>